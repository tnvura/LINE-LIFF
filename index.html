<!-- File: /index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>My First LIFF App</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; padding: 24px; }
    .card { max-width: 560px; margin: 0 auto; padding: 20px; border: 1px solid #ddd; border-radius: 12px; box-shadow: 0 1px 4px rgba(0,0,0,.06); }
    #profile-pic { width: 100px; height: 100px; border-radius: 50%; object-fit: cover; }
    #debug { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; background: #fafafa; border: 1px dashed #ccc; padding: 10px; border-radius: 8px; white-space: pre-wrap; }
    .row { display: flex; gap: 12px; align-items: center; }
    .btn { display: inline-block; padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; text-decoration: none; }
    .btn-primary { background: #06c755; color: #fff; border-color: #06c755; }
    .muted { color: #666; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Welcome to my LIFF App!</h1>
    <p id="status" class="muted">Initializing LIFF…</p>

    <div id="profile" style="display:none">
      <div class="row">
        <img id="profile-pic" alt="Profile picture" />
        <div>
          <h2 id="display-name" style="margin: 0 0 6px"></h2>
          <div id="user-id" class="muted"></div>
        </div>
      </div>
    </div>

    <div id="actions" style="margin-top:16px; display:none">
      <a id="login-btn" class="btn btn-primary" href="#">Login with LINE</a>
      <a id="open-liff-link" class="btn" target="_self">Open via LIFF</a>
      <a id="send-btn" class="btn" href="#" style="display:none">Send to n8n</a>
      <a id="send-json-btn" class="btn" href="#" style="display:none">Send JSON</a>
      <a id="send-get-btn" class="btn" href="#" style="display:none">Send GET</a>
    </div>

    <h3 style="margin-top:24px">Debug</h3>
    <div id="debug">(loading…)</div>
  </div>

  <!-- LIFF SDK -->
  <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>

  <script>
    const LIFF_ID = "2008075804-2AER9wYe"; // <- your LIFF ID
    const LIFF_URL = `https://liff.line.me/${LIFF_ID}`; // use this to launch inside LINE
    const WEBHOOK_URLS = [
      "https://n8n.tnvura.dev/webhook-test/1044c42f-7f8b-419f-8b02-9650a47623c0", // n8n Test URL (works only when the workflow is in Test mode)
      "https://n8n.tnvura.dev/webhook/1044c42f-7f8b-419f-8b02-9650a47623c0"      // n8n Production URL (active workflow)
    ]; // why: send to both to avoid silent misses

    const els = {
      status: document.getElementById("status"),
      profile: document.getElementById("profile"),
      pic: document.getElementById("profile-pic"),
      name: document.getElementById("display-name"),
      uid: document.getElementById("user-id"),
      actions: document.getElementById("actions"),
      loginBtn: document.getElementById("login-btn"),
      openLiff: document.getElementById("open-liff-link"),
      sendBtn: document.getElementById("send-btn"),
      debug: document.getElementById("debug"),
    };

    function setDebug(lines) {
      els.debug.textContent = Array.isArray(lines) ? lines.join("\n") : String(lines);
    }
    function appendDebug(line) {
      els.debug.textContent += ("\n" + line);
    }

    async function sendWebhookAuto(payload) {
      // Try beacon -> no-cors text -> get ping, to BOTH URLs
      let any = false;
      for (const url of WEBHOOK_URLS) {
        const data = JSON.stringify(payload);
        // 1) Beacon
        if (navigator.sendBeacon) {
          try {
            const ok = navigator.sendBeacon(url, new Blob([data], { type: "text/plain;charset=UTF-8" }));
            appendDebug(`beacon -> ${url} : ${ok ? 'queued' : 'failed'}`);
            any = any || ok;
            continue; // still try others
          } catch (e) { appendDebug(`beacon error -> ${url} : ${e}`); }
        }
        // 2) no-cors text
        try {
          await fetch(url, {
            method: "POST",
            mode: "no-cors",
            headers: { "Content-Type": "text/plain;charset=UTF-8" },
            body: data,
            keepalive: true,
          });
          appendDebug(`no-cors POST -> ${url} : sent`);
          any = true;
        } catch (e) { appendDebug(`no-cors error -> ${url} : ${e}`); }
        // 3) GET ping
        try {
          const img = new Image();
          const base64 = btoa(unescape(encodeURIComponent(data)));
          const p = encodeURIComponent(base64.slice(0, 1800));
          img.src = `${url}?p=${p}&_ts=${Date.now()}`;
          appendDebug(`GET ping -> ${img.src}`);
          any = true;
        } catch (e) { appendDebug(`GET ping error -> ${url} : ${e}`); }
      }
      return any;
    }

    async function sendWebhookJson(payload) {
      // JSON POST (requires CORS on n8n)
      let okAny = false;
      for (const url of WEBHOOK_URLS) {
        try {
          const res = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          appendDebug(`json POST -> ${url} : status ${res.status}`);
          okAny = okAny || res.ok;
        } catch (e) {
          appendDebug(`json error -> ${url} : ${e}`);
        }
      }
      return okAny;
    }

    async function sendWebhookGet(payload) {
      let any = false;
      for (const url of WEBHOOK_URLS) {
        try {
          const img = new Image();
          const base64 = btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
          const p = encodeURIComponent(base64.slice(0, 1800));
          img.src = `${url}?p=${p}&_ts=${Date.now()}`;
          appendDebug(`manual GET -> ${img.src}`);
          any = true;
        } catch (e) { appendDebug(`manual GET error -> ${url} : ${e}`); }
      }
      return any;
    }

    async function sendWebhook(payload) {
      const data = JSON.stringify(payload);

      // 1) Prefer Beacon API (no CORS, survives page unload)
      if (navigator.sendBeacon) {
        try {
          const ok = navigator.sendBeacon(WEBHOOK_URL, new Blob([data], { type: "text/plain;charset=UTF-8" }));
          if (ok) return true;
        } catch {}
      }

      // 2) Fallback: no-cors fetch using a simple content type to avoid preflight
      try {
        await fetch(WEBHOOK_URL, {
          method: "POST",
          mode: "no-cors",
          headers: { "Content-Type": "text/plain;charset=UTF-8" }, // why: keeps it a simple request, avoids OPTIONS
          body: data,
          keepalive: true,
        });
        // In no-cors we can't read status; assume success if no exception
        return true;
      } catch {}

      // 3) Last resort: GET image ping with compact payload (length-limited)
      try {
        const img = new Image();
        const base64 = btoa(unescape(encodeURIComponent(data)));
        const p = encodeURIComponent(base64.slice(0, 1800)); // guard overly long URLs
        img.src = `${WEBHOOK_URL}?p=${p}&_ts=${Date.now()}`;
        await new Promise((resolve) => {
          const t = setTimeout(resolve, 2500);
          img.onload = img.onerror = () => { clearTimeout(t); resolve(); };
        });
        return true;
      } catch {}

      return false;
    }

    function buildPayload({ profile, token, idp }) {({ profile, token, idp }) {
      return {
        ts: new Date().toISOString(),
        location: window.location.href,
        liff: {
          id: LIFF_ID,
          isInClient: safe(() => liff.isInClient()),
          isLoggedIn: safe(() => liff.isLoggedIn()),
          os: safe(() => liff.getOS()),
          language: safe(() => liff.getLanguage()),
          context: safe(() => liff.getContext()),
        },
        profile: {
          displayName: profile?.displayName || null,
          userId: profile?.userId || null,
          pictureUrl: profile?.pictureUrl || null,
          statusMessage: profile?.statusMessage || null,
        },
        tokens: {
          accessToken: token || null, // why: requested by user; sensitive
          idToken: safe(() => liff.getIDToken()) || null,
        },
        idTokenPayload: idp || null,
        userAgent: navigator.userAgent,
      };
    }

    function currentRelativePath()() {
      const rel = location.pathname + location.search + location.hash;
      return rel.startsWith('/') ? rel : ('/' + rel);
    }

    function buildLiffLaunchUrl() {
      // Preserve return path when launching via LIFF
      const state = encodeURIComponent(currentRelativePath());
      return `${LIFF_URL}?liff.state=${state}`;
    }

    function showOpenViaLiffUI(message) {
      els.status.textContent = message;
      els.actions.style.display = "block";
      els.loginBtn.style.display = "none"; // why: login() cannot be used reliably when not launched as LIFF inside the client
      els.openLiff.href = buildLiffLaunchUrl();
      els.openLiff.textContent = "Open with LIFF";
    }

    async function init() {
      try {
        await liff.init({ liffId: LIFF_ID, withLoginOnExternalBrowser: true });

        const inClient = liff.isInClient();
        const loggedIn = liff.isLoggedIn();
        const token = liff.getAccessToken();
        setDebug([
          `isInClient: ${inClient}`,
          `isLoggedIn: ${loggedIn}`,
          `hasAccessToken: ${Boolean(token)}`,
          `userAgent: ${navigator.userAgent}`,
        ]);

        if (!loggedIn) {
          if (inClient) {
            // In LINE's in-app browser but **not** launched as a LIFF app
            showOpenViaLiffUI("This page was opened as a normal web page inside LINE. Please open it via the official LIFF link.");
            return;
          }
          // External browser: trigger LINE Login and return here after auth
          els.status.textContent = "Redirecting to LINE Login…";
          liff.login({ redirectUri: window.location.href });
          return; // stop running after redirect call
        }

        // Logged in: ensure token before calling profile API
        if (!token) {
          showOpenViaLiffUI("Logged in but no access token. Please reopen via LIFF link.");
          return;
        }

        els.status.textContent = "Getting profile…";
        const profile = await liff.getProfile();

        els.name.textContent = `Hello, ${profile.displayName}!`;
        els.uid.textContent = profile.userId ? `User ID: ${profile.userId}` : "";
        if (profile.pictureUrl) els.pic.src = profile.pictureUrl;
        els.profile.style.display = "block";
        const idp = safe(() => liff.getDecodedIDToken());
        const payload = buildPayload({ profile, token, idp });

        // Auto-send once
        els.status.textContent = "Sending data to webhook…";
        const ok = await sendWebhook(payload);
        els.status.textContent = ok ? "" : "Webhook failed (network/CORS). Tap 'Send to n8n' to retry.";

        // Expose manual resend button
        els.sendBtn.style.display = "inline-block";
        els.sendJsonBtn.style.display = "inline-block";
        els.sendGetBtn.style.display = "inline-block";

        els.sendBtn.onclick = async (e) => {
          e.preventDefault();
          els.status.textContent = "Sending (auto)…";
          const sent = await sendWebhookAuto(payload);
          els.status.textContent = sent ? "Sent (auto)." : "Send failed.";
        };
        els.sendJsonBtn.onclick = async (e) => {
          e.preventDefault();
          els.status.textContent = "Sending (JSON)…";
          const sent = await sendWebhookJson(payload);
          els.status.textContent = sent ? "Sent (JSON)." : "JSON blocked by CORS (enable on n8n).";
        };
        els.sendGetBtn.onclick = async (e) => {
          e.preventDefault();
          els.status.textContent = "Sending (GET)…";
          const sent = await sendWebhookGet(payload);
          els.status.textContent = sent ? "Sent (GET)." : "GET failed.";
        };

      } catch (err) {
        // Expose useful error info for troubleshooting
        const msg = `Error initializing LIFF: ${err?.message || err}`;
        els.status.textContent = msg;
        setDebug([
          msg,
          `isInClient: ${safe(() => liff.isInClient())}`,
          `isLoggedIn: ${safe(() => liff.isLoggedIn())}`,
          `hasAccessToken: ${safe(() => Boolean(liff.getAccessToken()))}`,
        ]);
      }
    }

    function safe(fn) { try { return fn(); } catch { return "(n/a)"; } }

    // Manual login button for external browsers only
    els.loginBtn.addEventListener("click", (e) => {
      e.preventDefault();
      liff.login({ redirectUri: window.location.href });
    });

    // Prepare default LIFF link now so it's visible even before init completes
    els.openLiff.href = buildLiffLaunchUrl();

    init();
  </script>
</body>
</html>
